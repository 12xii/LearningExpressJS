# Object Oriented Programming

---

## 객체 Object

---

## 객체지향 프로그래밍

**Object Oriented Programming**

## 객체

### 객체지향 프로그래밍 OOP ; Object Oriented Programming

- 부품에 해당하는 객체를 먼저 제작, 조립해서 완성된 프로그램의 생성
- **캡슐화 Encapsulation**
    - 실제 구현 내용 은닉
    - 외부 객체는 내부의 구조를 알지 못하며 노출로 제공하는 필드, 메소드만 이용
    - 객체를 손상으로부터 보호
    - 접근 제한자 Access Modifier 사용
- **상속 Inheritance**
    - 상위 객체의 재사용으로 하위 객체 설계  → 중복 최소화
    - 상위 객체 수정이 모든 하위 객체의 수정 → 유지 보수 시간 최소화
- **다형성**

### 객체

- 물리적 / 추상적으로 생각할 수 있음
- 자신의 속성을 가지고 있음
- 식별 가능

**구성**

- 속성 = 필드
- 동작 = 메소드
    - 객체들 간의 상호작용 수단

**객체 모델링** Object Modeling

- 현실 세계의 객체 → 소프트웨어 객체로 설계
- 속성, 동작을 추려내어 **필드와 메소드로**

**객체 관계**

- **집합** 관계 (has-a)
- **사용** 관계
    - 객체 간의 상호작용
- **상속** 관계 (is-a)
    - 상위 객체 기반으로 
    하위 객체 생성

## 클래스

객체에 대한 설계도

- 클래스로 만들어진 **객체** : **인스턴스 instance**
    - **객체 제작 과정 : 인스턴스화**

**선언**

- 클래스 이름 작성 규칙
    1. 하나 이상의 문자
    2. 첫 글자로 숫자 금지
    3. $ _ 외의 특수문자 사용 불가
    4. 예약어 사용 불가

**사용**

클래스이름이 곧 소스파일의 이름

한 파일에 다수의 클래스 사용 가능 / 일반적으로 파일 1개당 클래스 1개

동일한 이름의 클래스 선언에만 public 접근 제한자 붙일 수 있음

```java
new className();
```

- 클래스로부터 객체 생성 연산자 `new`
    - 메모리 힙 영역에 객체 생성
    - 객체 주소 리턴

```java
ClassName variableName = new ClassName();
```

**용도**

- 라이브러리용
    - API  Application Program Interface
    - 다른 클래스에서 이용할 목적
- 실행용
    - main() 메소드 제공
    - 프로그램 전체에서 하나만 존재

라이브러리면서 실행용인 클래스 제작 가능하지만 대부분 분리

**구성**

```java
public class ClassName{

	int fieldname; // 필드 Field : 객체의 데이터 저장
	// 클래스 내부 전체에서 사용
	// 변수는 생성자와 메소드 내에서만 사용되며 생성자, 메소드 실행 종료시 자동 소멸되는 것
	
	ClassName(){  // 생성자 Constructor : 객체 생성 시 초기화 역할 담당
		// new 연산자로 호출되는 블록 스코프
		// 클래스 이름으로 되어 있음, 반환 타입 존재하지 않음
	}
	
	void methodName(){  // 메소드 Method : 객체의 동작에 해당하는 실행 블록
		// 필드 읽고 수정
		// 객체 간 데이터 전달의 수단
	}
}
```

- 필드
    - 저장 데이터
        - 고유 데이터
        - 가져야 할 부품
        - 현재 상태 데이터
    - 초기값 미지정 시 객체 생성될 경우 자동 기본 초기값으로 설정
    - 사용
        - 클래스 내부 : 단순 필드 이름으로 읽고 변경
        - 클래스 외부 : 우선 클래스로부터 객체 생성 → 필드 사용

## 생성자 Constructor

`new` 연산자와 같이 객체를 생성할 때 호출, 객체 초기화 담당

생성자 선언 생략 시 컴파일러는 기본 생성자를 바이트 코드에 자동 추가

- 클래스의 접근 제한자를 따라감

**선언**

```java
ClassName(variable){
	// 초기화 코드
}
```

**`this`** 키워드 사용

객체 자신의 참조

매개변수는 필드와 동일한 이름을 가지므로 생성자 내부에서 필드 접근 불가 → `this.` 키워드 사용

**생성과 초기화**

객체 생성 시 필드는 기본 초기값으로 자동 설정

- 필드 선언 시 초기값
- 생성자에서 초기값

⇒ 다른 값으로 초기화됨

일반적으로 중요한 몇 개 필드만 생성자 매개 변수를 통해 초기화한다

나머지는 필드 선언 시 / 생성자 내부 임의의 값으로 초기화되거나 객체 생성 이후 필드값을 별도로 저장

### 생성자 오버로딩

매개변수의 타입, 개수, 순서에 따라 생성자를 여러 개 생성 가능

생성자 내부에서 다른 생성자 호출 시 `this()` 코드 사용

```java
ClassName(variable){
	variable = a;
}

ClassName(variable, variable2){
	this(variable, 5) // variable = a, variable2 = 5로 초기화
}
```

`this()` 는 생성자의 첫 줄에서만 허용된다

## 메소드

- 객체의 동작에 해당하는 중괄호 스코프
- 필드를 읽고 수정하는 역할
- 다른 객체 생성 → 기능 수행
- 객체 간 데이터 전달 수단

```java
returnType methodName(variable){
	//...
}
```

** 리턴값 존재 여부에 따라 메소드 호출 방법이 다르다

```java
// No Return

run(); // 실행에 중점
```

```java
// Return

Scanner scanner = new Scanner(system.in);
int i = scanner.nextInt(); // 값에 중점
```

**작명 규칙**

- 숫자로 시작할 수 없다
- $, _ 제외 특수문자 사용 불가
- camel case로 작성

### 선언

매개변수의 개수 모를 경우 → 스프레드연산자 `...` 사용

```java
int sum(int ...x){ ... }
```

**return**

기능 : 반환, 종료

- Return A;
    - 리턴값은 리턴 타입이거나 리턴 타입으로 변환될 수 있어야 한다
    - return 이후에 실행문이 올 경우 `Unreacheable code` 에러 발생
        - 단 IF문 내의 return문이 있을 경우 그 밑에 실행문이 올 수 있다
- Return;
    - return 뒤에 매개변수를 두지 않으면 실행을 강제 종료시킨다

### 호출

클래스 내부 호출

- 단순 메소드 이름으로 호출

클래스 외부 호출

- 클래스로부터 객체 생성 → 참조 변수 이용해 메소드 호출

### 오버로딩 overloading

클래스 내 같은 이름의 메소드를 여러 개 선언

매개값을 다양하게 받아 처리할 수 있도록 하기 위해서

---